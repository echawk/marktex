#!/bin/sh
# Purpose here is to get all of the lines that are between '@l' tokens
# into their own tex file. This will then be '\input'ed into the file
# generated by lowdown

# count and file are the varaibles that we need to keep track of.
# this is what is responsible for handling the @l tokens, and latex
# code in between them

USAGE="Usage: marktex [-lgwmfch] [-i file]"
HELP="$USAGE
-i, --input FILE
	Set the input file to FILE
-l, --latex
	Set the output format to LaTeX
-g, --groff
	Set the output format to groff (ms macros)
-w, --html
	Set the output format to html
-m, --markdown
	Set the output format to be markdown (clears the document of any extensions)
-f, --github-flavored-markdown
	Set the output format to be github-flavored markdown
-c, --color-source
	Syntax highlight source code blocks
-h, --help
	Print this message
"
OUTFMT="latex"; ext="tex" ; highlightfmt="latexcolor"    ; lowdownfmt="latex"
COLOR_SOURCE="N"
for arg in "$@"
do
	case $arg in
		-l|--latex)
			OUTFMT="latex"; ext="tex" ; highlightfmt="latexcolor"    ; lowdownfmt="latex"
			shift
			;;
		-g|--groff)
			OUTFMT="groff"; ext="ms"  ; highlightfmt="groff_mm_color"; lowdownfmt="ms"
			shift
			;;
		-w|--html)
			OUTFMT="html" ; ext="html"; highlightfmt="html"          ; lowdownfmt="html"
			shift
			;;
		-m|--markdown)
			OUTFMT="md"   ; ext="md"  ; highlightfmt="latexcolor"    ; lowdownfmt="latex"
			shift
			;;
		-f|--github-flavored-markdown)
			OUTFMT="gfm"  ; ext="md"  ; highlightfmt=""              ; lowdownfmt=""
			shift
			;;
		-c|--color-source)
			COLOR_SOURCE=Y
			shift
			;;
		-h|--help)
			shift
			printf "%s" "$HELP"
			exit 1
			;;
		-i|--input)
			shift
			file="$1"
			shift
			;;
		*)
			shift
			;;
	esac
done

[ -z "$file" ] && echo "$USAGE" && echo "No file! Exiting..." && exit 1

echo "ext: $ext"
TEXCC=${TEXCC:-pdflatex}
GENFILES="$(mktemp)"

# markdown and github-flavored-markdown are special in that they
# require very minimal preprocessing. The only preprocessing they
# require is the removal of extensions, and fixing formatting.

# extract_text_between
#ex:
# $1 -> 13,43
# $2 -> file
# $3 -> count
# $4 -> re pattern
# $5 -> ident
extract_text_between(){
	# To get the start and end lines, I am using shell substring commands,
	# rather than using cut, because the information that I want is already
	# saved in a variable, and making a call to cut is wasted resources
	# It's more expensive to use external programs compared to internal ones ^^
	# ${1%%,*} - ie : 13,47 -> 13
	# ${1##,*} - ie : 13,47 -> 47
	start=${1%%,*}
	end=${1##*,}
	cf="$2-$5-$3.${ext}"
	re="$4"
	# extract out all of the text in between the start and end lines
	sed -n "${start},${end}p" "$2" > "$cf"
	# remove the marker for the raw blocks
	sed -E -i "/${re}/d" "$cf"
	# ${cf%%.*} - ie : file.name -> file
	sed "${start},${end}s/.*/@input@${cf}@/g" "copy-$2" > "copy-${cf%%.*}"
	# 'return' the copy file we just made
	printf "%s" "copy-${cf%%.*},${cf}"
}

# Handle the raw blocks
count=0
cp "${file}" "copy-${file}"
sed -n "/^@r$/=" "${file}" | awk '{if (NR % 2 == 0) {print $1} else {printf $1 "," }}' | while read -r LINE
do
	mv "$(extract_text_between "$LINE" "${file}" "$count" "@r" 'raw' | cut -d',' -f1)" "copy-$file"
	echo "${file}-${count}.${ext}" >> "$GENFILES"
	count=$((count + 1))
done

# Create the code files; both in the output document format and as an independent file (if applicable)
count=0
CODEBLOCK=N # Global variable to determine whether or not we have a code block in the file; if Y, then \usepackage[dvipsnames]{xcolor}
# Below is the regex pattern that denotes a code block
codeptrn='```@C@?[a-z]*@?[a-z]*'

grep -Eq "${codeptrn}" "${file}" && CODEBLOCK=Y

grep -E "${codeptrn}" "${file}" | cut -d"@" -f4 | sort -u | xargs -P0 -I{} rm -vf "{}"

sed -E -n "/^${codeptrn}/=" "${file}" | awk '{if (NR % 2 == 0) { print $1 } else { printf $1 "," }}' | while read -r LINE
do
	lang=$(sed -n "${LINE%%,*}p" "${file}" | cut -d'@' -f3)
	langfile="$(sed -n "${LINE%%,*}p" "${file}" | cut -d'@' -f4)"
	genfiles=$(extract_text_between "$LINE" "${file}" "$count" "${codeptrn}" 'code' )

	[ -n "$langfile" ] && cat "${genfiles##*,}" >> "$langfile"
	source-highlight --src-lang "${lang}" --out-format "${highlightfmt}" -o "${genfiles##*,}.${ext}" -i "${genfiles##*,}"
	rm "${genfiles##*,}"

	sed "${LINE%%,*},${LINE##*,}s/.*/@input@${genfiles##*,}.${ext}@/g" "copy-${file}" > "copy-${count}-${file}"
	mv "copy-${count}-${file}" "copy-${file}"
	echo "${genfiles##*,}.${ext}" >> "$GENFILES"
	count=$((count + 1))
done

# Create the citation files
count=0
sed -n "/@c.*@c.*/=" "${file}" | while read -r LINE
do
	cf="${count}-cite-${file}.${ext}"
	sed -n "${LINE}p" "${file}" > "$cf"
	case $OUTFMT in
		latex)
			sed -i -E -e "s=^[^@]*@c=@c=" -e "s/@c(.*)@c/\\\\autocite{\1}/g" "$cf"
			;;
		groff)
			sed -i -E -e "s=^[^@]*@c=@c=" -e "s/@c(.*)@c/\n.[\n\1\n.]\n/g" -e "s/;/\n/g" "$cf"
			;;
		html)
			#TODO: Add in HTML support
			;;
	esac
	sed "${LINE}s/@c.*@c/\n@input@${cf}@\n/" "copy-${file}" > "copy-${count}-${file}"
	mv "copy-${count}-${file}" "copy-${file}"
	echo "$cf" >> "$GENFILES"
	count=$((count + 1))
done

# Handle the Preamble block; this is only ran *once*
# Create the Preamble file
	#FIXME: LaTeX Only
if grep -E -q "^@p$" "${file}"
then
	PREAM=$(sed -n "/^@p$/=" "${file}" | awk '{if (NR % 2 == 0) {print $1} else {printf $1 "," }}')
	start=${PREAM%%,*}
	end=${PREAM##*,}
	sed -n "${start},${end}p" "${file}" > "preamble-${file}.${ext}"
	sed -i "/@p/d" "preamble-${file}.${ext}"
	sed -i "${start},${end}s/.*/@pre@preamble-${file}.${ext}@/g" "copy-${file}"
	echo "preamble-${file}.${ext}" >> "$GENFILES"
fi
# Now we are on to the @m tokens
#count=0; sed -n "/@m/=" ${file} | while read LINE
#do \
#	sed -n "${LINE}p" ${file} > ${count}-math-${file}.tex
#	sed -i -e "s=^[^@]*@m=@m=" -e "s/@m/$/g" ${count}-math-${file}.tex
#	sed "${LINE}s/@m.*@m/@input{${count}-math-${file}.tex}/" copy-${file} > copy-${count}-${file}
#	mv copy-${count}-${file} copy-${file}
#	count=$((count + 1))
#done

# Get rid of duplicate lines
uniq "copy-${file}" > "detex-${file}"
rm "copy-${file}"

# Comile the cleaned markdown with lowdown into the proper output format
lowdown -s -T"${lowdownfmt}" --parse-math "detex-${file}" -o "${file}.${ext}";
rm "detex-${file}"

if [ "$CODEBLOCK" = Y ]
then
	case $OUTFMT in
		latex) sed -i 's/age{xcolor}/age[dvipsnames]{xcolor}/' "${file}.${ext}";;
	esac
fi

# Add in the preamble and the actually input the '@input' files
#FIXME: LaTeX Only
#FIXME: Refactor - this is ugly
if grep -q "@pre@" "${file}.${ext}"
then
	PREAMINC=$(grep "@pre@" "${file}.${ext}" | sed -E "s=@pre@(.*)@=input{\1}=")
	sed -i -E  "s=^(\\\\documentclass\[[a-zA-Z0-9,]*\]\{[a-zA-Z]*})$=\1\n\n\\\\$PREAMINC=" "${file}.${ext}"
	sed -i -E "s=^@pre@.*$==" "${file}.${ext}"
fi

grep -E "@input@" "${file}.${ext}" | cut -d"@" -f3 | xargs -I{} sed -i -e "/@input@{}@/r {}" -e "/@input@{}@/d"  "${file}.${ext}"

# Compile with the right compiler
case $OUTFMT in
	latex) ${TEXCC} "${file}.${ext}";;
	groff) refer < "${file}.${ext}" | preconv | eqn -Tpdf | tbl | pic | groff -mspdf -Tpdf > "${file}.pdf";;
	html) ;;
esac

# Remove temporary files
xargs -P0 -I{} rm -v {} < "$GENFILES"
rm "$GENFILES"
