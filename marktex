#!/bin/sh
USAGE="Usage: marktex [-lgwmfch] [-i file]"
HELP="$USAGE
-i, --input FILE
	Set the input file to FILE
-l, --latex
	Set the output format to LaTeX
-g, --groff
	Set the output format to groff (ms macros)
-w, --html
	Set the output format to html
-m, --markdown
	Set the output format to be markdown (clears the document of any extensions)
-f, --github-flavored-markdown
	Set the output format to be github-flavored markdown
-c, --color-source
	Syntax highlight source code blocks
-h, --help
	Print this message
"
OUTFMT="latex"; ext="tex" ; highlightfmt="latexcolor"    ; lowdownfmt="latex"
COLOR_SOURCE="N"
for arg in "$@"
do
	case $arg in
		-l|--latex)
			OUTFMT="latex"; ext="tex" ; highlightfmt="latexcolor"    ; lowdownfmt="latex"
			shift
			;;
		-g|--groff)
			OUTFMT="groff"; ext="ms"  ; highlightfmt="groff_mm_color"; lowdownfmt="ms"
			shift
			;;
		-w|--html)
			OUTFMT="html" ; ext="html"; highlightfmt="html"          ; lowdownfmt="html"
			shift
			;;
		-m|--markdown)
			OUTFMT="md"   ; ext="md"  ; highlightfmt="latexcolor"    ; lowdownfmt="latex"
			shift
			;;
		-f|--github-flavored-markdown)
			OUTFMT="gfm"  ; ext="md"  ; highlightfmt=""              ; lowdownfmt=""
			shift
			;;
		-c|--color-source)
			COLOR_SOURCE=Y
			shift
			;;
		-h|--help)
			shift
			printf "%s" "$HELP"
			exit 0
			;;
		-i|--input)
			shift
			file="$1"
			shift
			;;
		*)
			# Below is a fix for kornshell compatible shells. If there is nothing left in the
			# arugment list to shift, then we break, otherwise, shift
			[ -z "$*" ] && break || shift
			;;
	esac
done

[ -z "$file" ] && echo "$USAGE" && echo "No file! Exiting..." && exit 1

TEXCC=${TEXCC:-pdflatex}
GENFILES="$(mktemp)"

# markdown and github-flavored-markdown are special in that they
# require very minimal preprocessing. The only preprocessing they
# require is the removal of extensions, and fixing formatting.
#FIXME: implement markdown and gfm here

# extract_text_between
#ex:
# $1 -> 13,43      - start and end line numbers
# $2 -> file       - the file to modify
# $3 -> count      - the current count (in reference to each loop)
# $4 -> re pattern - the regex pattern to remove from the extracted text
# $5 -> identifier - 'raw', 'code', etc.
extract_text_between(){
	# To get the start and end lines, I am using shell substring commands,
	# rather than using cut, because the information that I want is already
	# saved in a variable, and making a call to cut is wasted resources
	# It's more expensive to use external programs compared to internal ones ^^
	# ${1%%,*} - ie : 13,47 -> 13
	# ${1##,*} - ie : 13,47 -> 47
	start=${1%%,*}
	end=${1##*,}
	cf="$2-$5-$3.$ext"
	re="$4"
	# extract out all of the text in between the start and end lines
	sed -n "${start},${end}p" "$2" > "$cf"
	# remove the marker for the raw blocks
	sed -E -i "/${re}/d" "$cf"
	# ${cf%%.*} - ie : file.name -> file
	sed "${start},${end}s/.*/@input@${cf}@/g" "copy-$2" > "copy-${cf%%.*}"
	# 'return' the copy file we just made
	printf "%s" "copy-${cf%%.*},${cf}"
}

# Handle the raw blocks
count=0
cp "$file" "copy-$file"
grep -q "@r" "$file" && {
# The sed call here returns the line numbers that start with the specified regex. We also know that the
# 'blocks' are containted between every two numbers, so we combine the numbers onto the same line using
# paste. This produces the proper input for the 'extract_text_between' procedure that is above
sed -n "/^@r$/=" "$file" | paste -d"," - - | while read -r LINE
do
	# Here we are moving the freshly generated file to copy-$file so that our changes are saved
	# iteratively
	mv "$(extract_text_between "$LINE" "$file" "$count" "@r" 'raw' | cut -d',' -f1)" "copy-$file"
	echo "$file-raw-$count.$ext" >> "$GENFILES"
	count=$((count + 1))
done
}
# Create the code files; both in the output document format and as an independent file (if applicable)
count=0
# Below is the regex pattern that denotes a code block delimiter
RE_CODE='```>[a-z]*>?[a-z]*'

grep -qE "${RE_CODE}" "$file" && {
	# we remove the files that are going to be generated so we fit the spec
	grep -E "${RE_CODE}" "$file" | cut -d">" -f3 | sort -u | xargs -P0 -I{} rm -vf "{}"
	sed -E -n "/^${RE_CODE}/=" "$file" | paste -d"," - - | while read -r LINE
	do
		start=${LINE%%,*}
		end=${LINE##*,}
		lang=$(sed -n "${start}p" "$file" | cut -d'>' -f2)
		langfile="$(sed -n "${start}p" "$file" | cut -d'>' -f3)"
		genfiles=$(extract_text_between "$LINE" "$file" "$count" "$RE_CODE" 'code' )
		file_with_extracted_text="${genfiles##*,}"
		[ -n "$langfile" ] && cat "$file_with_extracted_text" >> "$langfile"
		[ $COLOR_SOURCE = Y ] && {
			source-highlight --src-lang "$lang" --out-format "$highlightfmt" -o "$file_with_extracted_text.$ext" -i "$file_with_extracted_text"
			sed -i "${start},${end}s/.*/@input@$file_with_extracted_text.$ext@/g" "copy-$file"
			echo "$file_with_extracted_text.$ext" >> "$GENFILES"
		} || {
			# if we aren't coloring code, then just transform the 'RE_CODE' into '```'
			a='```'
			sed -E -i "s/$RE_CODE/$a/;s/$a.*/$a/" "copy-$file"
		}
		count=$((count + 1))
		rm "$file_with_extracted_text"
		lang="" langfile=""
	done
}

# Create the citation files
count=0
RE_CITE='@c.*@c'
grep -qE "$RE_CITE.*" "$file" && {
	HAS_CITATIONS=yes
	sed -n "/$RE_CITE/=" "$file" | while read -r LINE
	do
		cf="$count-cite-$file.$ext"
		sed -n "${LINE}p" "$file" > "$cf"
		case $OUTFMT in
			latex) sed -i -E -e "s=^[^@]*@c=@c=" -e "s/@c(.*)@c/\\\\autocite{\1}/g" "$cf" ;;
			groff) sed -i -E -e "s=^[^@]*@c=@c=" -e "s/@c(.*)@c/\n.[\n\1\n.]\n/g" -e "s/;/\n/g" "$cf" ;;
			html) ;; #TODO: Add in HTML support
		esac
		sed -i "${LINE}s/$RE_CITE/\n@input@${cf}@\n/" "copy-$file"
		echo "$cf" >> "$GENFILES"
		count=$((count + 1))
	done
}
# Handle the Preamble block; this is only ran *once*
# Create the Preamble file
# FIXME: LaTeX Only
if grep -E -q "^@p$" "$file"
then
	PREAM=$(sed -n "/^@p$/=" "$file" | paste -d"," - - )
	start=${PREAM%%,*}
	end=${PREAM##*,}
	sed -n "${start},${end}p" "$file" > "preamble-$file.$ext"
	sed -i "/@p/d" "preamble-$file.$ext"
	sed -i "${start},${end}s/.*/@pre@preamble-$file.$ext@/g" "copy-$file"
	echo "preamble-$file.$ext" >> "$GENFILES"
fi

# Get rid of duplicate lines and Comile the cleaned markdown with lowdown into the proper output format
uniq "copy-$file" | lowdown -s -T"$lowdownfmt" --parse-math -o "$file.$ext";
rm "copy-$file"

case $OUTFMT in
	latex) sed -i 's/age{xcolor}/age[dvipsnames]{xcolor}/' "$file.$ext";;
esac

# Add in the preamble and the actually input the '@input' files
#FIXME: LaTeX Only
#FIXME: Refactor - this is ugly
if grep -q "@pre@" "$file.$ext"
then
	PREAMINC=$(grep "@pre@" "$file.$ext" | sed -E "s=@pre@(.*)@=input{\1}=")
	sed -i -E -e "s=^(\\\\documentclass\[[a-zA-Z0-9,]*\]\{[a-zA-Z]*})$=\1\n\n\\\\$PREAMINC=" -e "/^@pre@.*$/d" "$file.$ext"
fi

grep -E "@input@" "$file.$ext" | cut -d"@" -f3 | xargs -I{} sed -i -e "/@input@{}@/r {}" -e "/@input@{}@/d"  "$file.$ext"

# Compile with the right compiler
case $OUTFMT in
	latex) ${TEXCC} "$file.$ext"
		[ -n "$HAS_CITATIONS" ] && {
			grep -q biber "$file.$ext" && {
				biber "$file"
			} || {
				bibtex "$file"
			}
			${TEXCC} "$file.$ext"
		}
		latexmk -c -f "$file.$ext";;
	groff) gc=tee; which grap && gc=grap; refer < "$file.$ext" | preconv | eqn -Tpdf | tbl | $gc | pic | groff -mspdf -Tpdf > "$file.pdf";;
	html) ;;
esac

# Remove temporary files
xargs -P0 -I{} rm -v {} < "$GENFILES"
rm "$GENFILES"
