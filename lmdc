#!/bin/sh
USAGE="Usage: marktex [-lgwmfch] [-i file]"
HELP="$USAGE
-i, --input FILE
	Set the input file to FILE
-l, --latex
	Set the output format to LaTeX
-g, --groff
	Set the output format to groff (ms macros)
-w, --html
	Set the output format to html
-m, --markdown
	Set the output format to be markdown (clears the document of any extensions)
-f, --github-flavored-markdown
	Set the output format to be github-flavored markdown
-c, --color-source
	Syntax highlight source code blocks
-h, --help
	Print this message
"
OUTFMT="latex"; ext="tex" ; highlightfmt="latexcolor"    ; lowdownfmt="latex"
COLOR_SOURCE="N"
for arg in "$@"
do
	case $arg in
		-l|--latex)
			OUTFMT="latex"; ext="tex" ; highlightfmt="latexcolor"    ; lowdownfmt="latex"
			shift
			;;
		-g|--groff)
			OUTFMT="groff"; ext="ms"  ; highlightfmt="groff_mm_color"; lowdownfmt="ms"
			shift
			;;
		-w|--html)
			OUTFMT="html" ; ext="html"; highlightfmt="html"          ; lowdownfmt="html"
			shift
			;;
		-m|--markdown)
			OUTFMT="md"   ; ext="md"  ; highlightfmt="latexcolor"    ; lowdownfmt="latex"
			shift
			;;
		-f|--github-flavored-markdown)
			OUTFMT="gfm"  ; ext="md"  ; highlightfmt=""              ; lowdownfmt=""
			shift
			;;
		-c|--color-source)
			COLOR_SOURCE=Y
			shift
			;;
		-h|--help)
			shift
			printf "%s" "$HELP"
			exit 0
			;;
		-i|--input)
			shift
			file="$1"
			shift
			;;
		*)
			# Below is a fix for kornshell compatible shells. If there is nothing left in the
			# arugment list to shift, then we break, otherwise, shift
			[ -z "$*" ] && break || shift
			;;
	esac
done

[ -z "$file" ] && echo "$USAGE" && echo "No file! Exiting..." && exit 1

TEXCC=${TEXCC:-pdflatex}
GENFILES="$(mktemp)"

# markdown and github-flavored-markdown are special in that they
# require very minimal preprocessing. The only preprocessing they
# require is the removal of extensions, and fixing formatting.
#FIXME: implement markdown and gfm here

#ex:
# $1 -> 13,43      - start and end line numbers
# $2 -> copy-file  - the file to modify
# $3 -> i          - the current i (in reference to each loop)
# $4 -> re pattern - the regex pattern to remove from the extracted text
# $5 -> identifier - 'raw', 'code', etc.
extract_text_between(){
	s=${1%%,*}      # ${1%%,*} - ie : 13,47 -> 13
	e=${1##*,}        # ${1##,*} - ie : 13,47 -> 47
	cf="$2-$5-$3.$ext"
	re="$4"
	# extract out all of the text in between the start and end lines
	sed -n "${s},${e}p" "$2" > "$cf"
	# remove the marker for the raw blocks
	sed -E -i "/${re}/d" "$cf"
	# ${cf%%.*} - ie : file.name -> file
	sed "${s},${e}s/.*/@input@${cf}@/g" "$2" > "copy-${cf%%.*}"
	# return 'copy-file,file.name'
	printf "%s" "copy-${cf%%.*},${cf}"
}

i=0
RE_RAW="^@r$"
cp "$file" "copy-$file"
grep -qE "$RE_RAW" "$file" && {
# The sed call here returns the line numbers that start with the specified regex. We also know that the
# 'blocks' are containted between every two numbers, so we combine the numbers onto the same line using
# paste. This produces the proper input for the 'extract_text_between' procedure that is above
sed -n "/$RE_RAW/=" "$file" | paste -d"," - - | while read -r COORDS
do
	# Here we are moving the freshly generated file to copy-$file so that our changes are saved
	# iteratively
	mv "$(extract_text_between "$COORDS" "$file" "$i" "@r" 'raw' | cut -d',' -f1)" "copy-$file"
	echo "$file-raw-$i.$ext" >> "$GENFILES"
	i=$((i + 1))
done
}

RE_CODE='```>[a-z]*>?[a-z]*'
# read in source files and create code blocks
grep -qE "^[^>]+>${RE_CODE}" "$file" && {
	input_files="$(grep -E "^[^>]+>${RE_CODE}" "$file" | cut -d'>' -f1)"
	for f in $input_files
	do
		origline="$(grep -E "$f>${RE_CODE}" "$file" | sed 1q )"
		newline="${origline#*>}" # proper format for the code file handling below
		echo "$newline" > "$f.md"
		cat "$f" >> "$f.md"
		echo "$newline" >> "$f.md"
		sed -i -E -e "/${f}>${RE_CODE}/r $f.md" -e "/${f}>${RE_CODE}/d" "copy-$file"
		echo "$f.md" >> "$GENFILES"
	done
}

# Create the code files; both in the output document format and as an independent file (if applicable)
i=0
grep -qE "${RE_CODE}" "copy-$file" && {
	# we remove the files that are going to be generated so we fit the spec
	grep -E "${RE_CODE}" "copy-$file" | cut -d">" -f3 | sort -u | xargs -P0 -I{} rm -vf "{}"
	sed -E -n "/^${RE_CODE}/=" "copy-$file" | paste -d"," - - | while read -r COORDS
	do
		start=${COORDS%%,*}
		end=${COORDS##*,}
		lang=$(sed -n "${start}p" "copy-$file" | cut -d'>' -f2)
		langfile="$(sed -n "${start}p" "copy-$file" | cut -d'>' -f3)"
		genfiles=$(extract_text_between "$COORDS" "copy-$file" "$i" "$RE_CODE" 'code' )
		file_with_extracted_text="${genfiles##*,}"
		[ -n "$langfile" ] && cat "$file_with_extracted_text" >> "$langfile"
		if [ $COLOR_SOURCE = Y ] ; then
			source-highlight --src-lang "$lang" --out-format "$highlightfmt" -o "$file_with_extracted_text.$ext" -i "$file_with_extracted_text"
			sed -i "${start},${end}s/.*/@input@$file_with_extracted_text.$ext@/g" "copy-$file"
			echo "$file_with_extracted_text.$ext" >> "$GENFILES"
		else
			# if we aren't coloring code, then just transform 'RE_CODE' into '```'
			a='```'
			sed -E -i -e "${COORDS}s/$RE_CODE/$a/" -e "${COORDS}s/$a.*/$a/" "copy-$file"
			unset a
		fi
		i=$((i + 1))
		rm "$file_with_extracted_text"
		lang="" langfile=""
	done
}

i=0
RE_CITE='@c.*@c'
grep -qE "$RE_CITE.*" "$file" && {
	HAS_CITATIONS=yes
	sed -n "/$RE_CITE/=" "$file" | while read -r COORDS
	do
		cf="$i-cite-$file.$ext"
		sed -n "${COORDS}p" "$file" > "$cf"
		case $OUTFMT in
			latex) sed -i -E -e "s=^[^@]*@c=@c=;s/@c(.*)@c/\\\\autocite{\1}/g" "$cf" ;;
			groff) sed -i -E -e "s=^[^@]*@c=@c=;s/@c(.*)@c/\n.[\n\1\n.]\n/g" -e "s/;/\n/g" "$cf" ;;
			html) ;; #TODO: Add in HTML support
		esac
		sed -i "${COORDS}s/$RE_CITE/\n@input@${cf}@\n/" "copy-$file"
		echo "$cf" >> "$GENFILES"
		i=$((i + 1))
	done
}

# Handle the Preamble block; this is only ran *once*
if grep -E -q "^@p$" "$file"
then
	PREAM=$(sed -n "/^@p$/=" "$file" | paste -d"," - - )
	start=${PREAM%%,*}
	end=${PREAM##*,}
	sed -n "${start},${end}p" "$file" > "preamble-$file.$ext"
	sed -i "/@p/d" "preamble-$file.$ext"
	sed -i "${start},${end}s/.*/@pre@preamble-$file.$ext@/g" "copy-$file"
	echo "preamble-$file.$ext" >> "$GENFILES"
fi

# Get rid of duplicate lines and Comile the cleaned markdown with lowdown into the proper output format
uniq "copy-$file" | lowdown -s -T"$lowdownfmt" --parse-math -o "$file.$ext";
rm "copy-$file"

case $OUTFMT in
	latex) sed -i 's/age{xcolor}/age[dvipsnames]{xcolor}/;/title{Untitled article}/d' "$file.$ext";;
esac

# Add in the preamble and the actually input the '@input' files
if grep -q "@pre@" "$file.$ext"
then
	preamfile="preamble-$file.$ext"
	case $OUTFMT in
		latex)
			genpream="$(sed -n "/documentclass/=;/begin{document}/=" "$file.$ext" | paste -d"," - -)"
			sed -n "${genpream}p" "$file.$ext" > "gen-$preamfile"
			echo "gen-$preamfile" >> "$GENFILES"
			sed -i "${genpream}d" "$file.$ext"
			if grep -q "documentclass" "$preamfile"
			then
				sed -i "s/documentclass.*/$(grep "documentclass" "$preamfile")/" "gen-$preamfile"
				sed -i "/.*documentclass.*/d" "$preamfile"
			fi
			tac "$preamfile" > _ ; mv _ "$preamfile"
			tac "gen-$preamfile" | sed "/begin{document}/r $preamfile" | tac > "final-$preamfile"
			echo "final-$preamfile" >> "$GENFILES"
			cat "final-$preamfile" "$file.$ext" > _ ; mv _ "$file.$ext"
		;;
		groff)
			cat "$preamfile" "$file.$ext" > _ ; mv _ "$file.$ext"
		;;
	esac
	sed -i -E "/^@pre@.*$/d" "$file.$ext"
fi

grep -E "@input@" "$file.$ext" | cut -d"@" -f3 | xargs -I{} sed -i -e "/@input@{}@/r {}" -e "/@input@{}@/d"  "$file.$ext"

# Compile with the right compiler
case $OUTFMT in
	latex) ${TEXCC} "$file.$ext"
		[ -n "$HAS_CITATIONS" ] && {
			if grep -q biber "$file.$ext" ; then
				biber "$file"
			else
				bibtex "$file"
			fi
			${TEXCC} "$file.$ext"
		}
		latexmk -c -f "$file.$ext";;
	groff) gc="tee"; which grap && gc="grap"; refer < "$file.$ext" | preconv | eqn -Tpdf | tbl | $gc | pic | groff -mspdf -Tpdf > "$file.pdf";;
	html) ;;
esac

# Remove temporary files
xargs -P0 -I{} rm -v {} < "$GENFILES"
rm "$GENFILES"
